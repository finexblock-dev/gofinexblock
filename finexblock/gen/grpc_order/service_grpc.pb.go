// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.3
// source: proto/grpc_order/service.proto

package grpc_order

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	MarketOrder_MarketOrderInit_FullMethodName = "/grpc_order.MarketOrder/MarketOrderInit"
)

// MarketOrderClient is the client API for MarketOrder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarketOrderClient interface {
	MarketOrderInit(ctx context.Context, in *MarketOrderInput, opts ...grpc.CallOption) (*Ack, error)
}

type marketOrderClient struct {
	cc grpc.ClientConnInterface
}

func NewMarketOrderClient(cc grpc.ClientConnInterface) MarketOrderClient {
	return &marketOrderClient{cc}
}

func (c *marketOrderClient) MarketOrderInit(ctx context.Context, in *MarketOrderInput, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MarketOrder_MarketOrderInit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarketOrderServer is the server API for MarketOrder service.
// All implementations must embed UnimplementedMarketOrderServer
// for forward compatibility
type MarketOrderServer interface {
	MarketOrderInit(context.Context, *MarketOrderInput) (*Ack, error)
	mustEmbedUnimplementedMarketOrderServer()
}

// UnimplementedMarketOrderServer must be embedded to have forward compatible implementations.
type UnimplementedMarketOrderServer struct {
}

func (UnimplementedMarketOrderServer) MarketOrderInit(context.Context, *MarketOrderInput) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketOrderInit not implemented")
}
func (UnimplementedMarketOrderServer) mustEmbedUnimplementedMarketOrderServer() {}

// UnsafeMarketOrderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarketOrderServer will
// result in compilation errors.
type UnsafeMarketOrderServer interface {
	mustEmbedUnimplementedMarketOrderServer()
}

func RegisterMarketOrderServer(s grpc.ServiceRegistrar, srv MarketOrderServer) {
	s.RegisterService(&MarketOrder_ServiceDesc, srv)
}

func _MarketOrder_MarketOrderInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketOrderInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketOrderServer).MarketOrderInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MarketOrder_MarketOrderInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketOrderServer).MarketOrderInit(ctx, req.(*MarketOrderInput))
	}
	return interceptor(ctx, in, info, handler)
}

// MarketOrder_ServiceDesc is the grpc.ServiceDesc for MarketOrder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MarketOrder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.MarketOrder",
	HandlerType: (*MarketOrderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MarketOrderInit",
			Handler:    _MarketOrder_MarketOrderInit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	LimitOrder_LimitOrderInit_FullMethodName = "/grpc_order.LimitOrder/LimitOrderInit"
)

// LimitOrderClient is the client API for LimitOrder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LimitOrderClient interface {
	LimitOrderInit(ctx context.Context, in *LimitOrderInput, opts ...grpc.CallOption) (*Ack, error)
}

type limitOrderClient struct {
	cc grpc.ClientConnInterface
}

func NewLimitOrderClient(cc grpc.ClientConnInterface) LimitOrderClient {
	return &limitOrderClient{cc}
}

func (c *limitOrderClient) LimitOrderInit(ctx context.Context, in *LimitOrderInput, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, LimitOrder_LimitOrderInit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LimitOrderServer is the server API for LimitOrder service.
// All implementations must embed UnimplementedLimitOrderServer
// for forward compatibility
type LimitOrderServer interface {
	LimitOrderInit(context.Context, *LimitOrderInput) (*Ack, error)
	mustEmbedUnimplementedLimitOrderServer()
}

// UnimplementedLimitOrderServer must be embedded to have forward compatible implementations.
type UnimplementedLimitOrderServer struct {
}

func (UnimplementedLimitOrderServer) LimitOrderInit(context.Context, *LimitOrderInput) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitOrderInit not implemented")
}
func (UnimplementedLimitOrderServer) mustEmbedUnimplementedLimitOrderServer() {}

// UnsafeLimitOrderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LimitOrderServer will
// result in compilation errors.
type UnsafeLimitOrderServer interface {
	mustEmbedUnimplementedLimitOrderServer()
}

func RegisterLimitOrderServer(s grpc.ServiceRegistrar, srv LimitOrderServer) {
	s.RegisterService(&LimitOrder_ServiceDesc, srv)
}

func _LimitOrder_LimitOrderInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LimitOrderInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LimitOrderServer).LimitOrderInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LimitOrder_LimitOrderInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LimitOrderServer).LimitOrderInit(ctx, req.(*LimitOrderInput))
	}
	return interceptor(ctx, in, info, handler)
}

// LimitOrder_ServiceDesc is the grpc.ServiceDesc for LimitOrder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LimitOrder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.LimitOrder",
	HandlerType: (*LimitOrderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LimitOrderInit",
			Handler:    _LimitOrder_LimitOrderInit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	CancelOrder_CancelOrder_FullMethodName = "/grpc_order.CancelOrder/CancelOrder"
)

// CancelOrderClient is the client API for CancelOrder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CancelOrderClient interface {
	CancelOrder(ctx context.Context, in *OrderCancellation, opts ...grpc.CallOption) (*Ack, error)
}

type cancelOrderClient struct {
	cc grpc.ClientConnInterface
}

func NewCancelOrderClient(cc grpc.ClientConnInterface) CancelOrderClient {
	return &cancelOrderClient{cc}
}

func (c *cancelOrderClient) CancelOrder(ctx context.Context, in *OrderCancellation, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, CancelOrder_CancelOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CancelOrderServer is the server API for CancelOrder service.
// All implementations must embed UnimplementedCancelOrderServer
// for forward compatibility
type CancelOrderServer interface {
	CancelOrder(context.Context, *OrderCancellation) (*Ack, error)
	mustEmbedUnimplementedCancelOrderServer()
}

// UnimplementedCancelOrderServer must be embedded to have forward compatible implementations.
type UnimplementedCancelOrderServer struct {
}

func (UnimplementedCancelOrderServer) CancelOrder(context.Context, *OrderCancellation) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedCancelOrderServer) mustEmbedUnimplementedCancelOrderServer() {}

// UnsafeCancelOrderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CancelOrderServer will
// result in compilation errors.
type UnsafeCancelOrderServer interface {
	mustEmbedUnimplementedCancelOrderServer()
}

func RegisterCancelOrderServer(s grpc.ServiceRegistrar, srv CancelOrderServer) {
	s.RegisterService(&CancelOrder_ServiceDesc, srv)
}

func _CancelOrder_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCancellation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CancelOrderServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CancelOrder_CancelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CancelOrderServer).CancelOrder(ctx, req.(*OrderCancellation))
	}
	return interceptor(ctx, in, info, handler)
}

// CancelOrder_ServiceDesc is the grpc.ServiceDesc for CancelOrder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CancelOrder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.CancelOrder",
	HandlerType: (*CancelOrderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelOrder",
			Handler:    _CancelOrder_CancelOrder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	Event_OrderPlacementEvent_FullMethodName          = "/grpc_order.Event/OrderPlacementEvent"
	Event_OrderPlacementFailedEvent_FullMethodName    = "/grpc_order.Event/OrderPlacementFailedEvent"
	Event_OrderCancellationEvent_FullMethodName       = "/grpc_order.Event/OrderCancellationEvent"
	Event_OrderCancellationFailedEvent_FullMethodName = "/grpc_order.Event/OrderCancellationFailedEvent"
	Event_OrderMatchingEvent_FullMethodName           = "/grpc_order.Event/OrderMatchingEvent"
	Event_OrderMatchingFailedEvent_FullMethodName     = "/grpc_order.Event/OrderMatchingFailedEvent"
	Event_OrderPartialFillEvent_FullMethodName        = "/grpc_order.Event/OrderPartialFillEvent"
	Event_OrderFulfillmentEvent_FullMethodName        = "/grpc_order.Event/OrderFulfillmentEvent"
	Event_OrderInitializeEvent_FullMethodName         = "/grpc_order.Event/OrderInitializeEvent"
	Event_BalanceUpdateEvent_FullMethodName           = "/grpc_order.Event/BalanceUpdateEvent"
)

// EventClient is the client API for Event service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventClient interface {
	OrderPlacementEvent(ctx context.Context, in *OrderPlacement, opts ...grpc.CallOption) (*Ack, error)
	OrderPlacementFailedEvent(ctx context.Context, in *OrderPlacementFailed, opts ...grpc.CallOption) (*Ack, error)
	OrderCancellationEvent(ctx context.Context, in *OrderCancelled, opts ...grpc.CallOption) (*Ack, error)
	OrderCancellationFailedEvent(ctx context.Context, in *OrderCancellationFailed, opts ...grpc.CallOption) (*Ack, error)
	OrderMatchingEvent(ctx context.Context, in *OrderMatching, opts ...grpc.CallOption) (*Ack, error)
	OrderMatchingFailedEvent(ctx context.Context, in *OrderMatchingFailed, opts ...grpc.CallOption) (*Ack, error)
	OrderPartialFillEvent(ctx context.Context, in *OrderPartialFill, opts ...grpc.CallOption) (*Ack, error)
	OrderFulfillmentEvent(ctx context.Context, in *OrderFulfillment, opts ...grpc.CallOption) (*Ack, error)
	OrderInitializeEvent(ctx context.Context, in *OrderInitialize, opts ...grpc.CallOption) (*Ack, error)
	BalanceUpdateEvent(ctx context.Context, in *BalanceUpdate, opts ...grpc.CallOption) (*Ack, error)
}

type eventClient struct {
	cc grpc.ClientConnInterface
}

func NewEventClient(cc grpc.ClientConnInterface) EventClient {
	return &eventClient{cc}
}

func (c *eventClient) OrderPlacementEvent(ctx context.Context, in *OrderPlacement, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderPlacementEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderPlacementFailedEvent(ctx context.Context, in *OrderPlacementFailed, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderPlacementFailedEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderCancellationEvent(ctx context.Context, in *OrderCancelled, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderCancellationEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderCancellationFailedEvent(ctx context.Context, in *OrderCancellationFailed, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderCancellationFailedEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderMatchingEvent(ctx context.Context, in *OrderMatching, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderMatchingEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderMatchingFailedEvent(ctx context.Context, in *OrderMatchingFailed, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderMatchingFailedEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderPartialFillEvent(ctx context.Context, in *OrderPartialFill, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderPartialFillEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderFulfillmentEvent(ctx context.Context, in *OrderFulfillment, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderFulfillmentEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) OrderInitializeEvent(ctx context.Context, in *OrderInitialize, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_OrderInitializeEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventClient) BalanceUpdateEvent(ctx context.Context, in *BalanceUpdate, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, Event_BalanceUpdateEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServer is the server API for Event service.
// All implementations must embed UnimplementedEventServer
// for forward compatibility
type EventServer interface {
	OrderPlacementEvent(context.Context, *OrderPlacement) (*Ack, error)
	OrderPlacementFailedEvent(context.Context, *OrderPlacementFailed) (*Ack, error)
	OrderCancellationEvent(context.Context, *OrderCancelled) (*Ack, error)
	OrderCancellationFailedEvent(context.Context, *OrderCancellationFailed) (*Ack, error)
	OrderMatchingEvent(context.Context, *OrderMatching) (*Ack, error)
	OrderMatchingFailedEvent(context.Context, *OrderMatchingFailed) (*Ack, error)
	OrderPartialFillEvent(context.Context, *OrderPartialFill) (*Ack, error)
	OrderFulfillmentEvent(context.Context, *OrderFulfillment) (*Ack, error)
	OrderInitializeEvent(context.Context, *OrderInitialize) (*Ack, error)
	BalanceUpdateEvent(context.Context, *BalanceUpdate) (*Ack, error)
	mustEmbedUnimplementedEventServer()
}

// UnimplementedEventServer must be embedded to have forward compatible implementations.
type UnimplementedEventServer struct {
}

func (UnimplementedEventServer) OrderPlacementEvent(context.Context, *OrderPlacement) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderPlacementEvent not implemented")
}
func (UnimplementedEventServer) OrderPlacementFailedEvent(context.Context, *OrderPlacementFailed) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderPlacementFailedEvent not implemented")
}
func (UnimplementedEventServer) OrderCancellationEvent(context.Context, *OrderCancelled) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCancellationEvent not implemented")
}
func (UnimplementedEventServer) OrderCancellationFailedEvent(context.Context, *OrderCancellationFailed) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCancellationFailedEvent not implemented")
}
func (UnimplementedEventServer) OrderMatchingEvent(context.Context, *OrderMatching) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderMatchingEvent not implemented")
}
func (UnimplementedEventServer) OrderMatchingFailedEvent(context.Context, *OrderMatchingFailed) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderMatchingFailedEvent not implemented")
}
func (UnimplementedEventServer) OrderPartialFillEvent(context.Context, *OrderPartialFill) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderPartialFillEvent not implemented")
}
func (UnimplementedEventServer) OrderFulfillmentEvent(context.Context, *OrderFulfillment) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderFulfillmentEvent not implemented")
}
func (UnimplementedEventServer) OrderInitializeEvent(context.Context, *OrderInitialize) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderInitializeEvent not implemented")
}
func (UnimplementedEventServer) BalanceUpdateEvent(context.Context, *BalanceUpdate) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BalanceUpdateEvent not implemented")
}
func (UnimplementedEventServer) mustEmbedUnimplementedEventServer() {}

// UnsafeEventServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServer will
// result in compilation errors.
type UnsafeEventServer interface {
	mustEmbedUnimplementedEventServer()
}

func RegisterEventServer(s grpc.ServiceRegistrar, srv EventServer) {
	s.RegisterService(&Event_ServiceDesc, srv)
}

func _Event_OrderPlacementEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderPlacement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderPlacementEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderPlacementEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderPlacementEvent(ctx, req.(*OrderPlacement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderPlacementFailedEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderPlacementFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderPlacementFailedEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderPlacementFailedEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderPlacementFailedEvent(ctx, req.(*OrderPlacementFailed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderCancellationEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCancelled)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderCancellationEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderCancellationEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderCancellationEvent(ctx, req.(*OrderCancelled))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderCancellationFailedEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCancellationFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderCancellationFailedEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderCancellationFailedEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderCancellationFailedEvent(ctx, req.(*OrderCancellationFailed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderMatchingEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderMatching)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderMatchingEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderMatchingEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderMatchingEvent(ctx, req.(*OrderMatching))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderMatchingFailedEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderMatchingFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderMatchingFailedEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderMatchingFailedEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderMatchingFailedEvent(ctx, req.(*OrderMatchingFailed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderPartialFillEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderPartialFill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderPartialFillEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderPartialFillEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderPartialFillEvent(ctx, req.(*OrderPartialFill))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderFulfillmentEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFulfillment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderFulfillmentEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderFulfillmentEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderFulfillmentEvent(ctx, req.(*OrderFulfillment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_OrderInitializeEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderInitialize)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).OrderInitializeEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_OrderInitializeEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).OrderInitializeEvent(ctx, req.(*OrderInitialize))
	}
	return interceptor(ctx, in, info, handler)
}

func _Event_BalanceUpdateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServer).BalanceUpdateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Event_BalanceUpdateEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServer).BalanceUpdateEvent(ctx, req.(*BalanceUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

// Event_ServiceDesc is the grpc.ServiceDesc for Event service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Event_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.Event",
	HandlerType: (*EventServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrderPlacementEvent",
			Handler:    _Event_OrderPlacementEvent_Handler,
		},
		{
			MethodName: "OrderPlacementFailedEvent",
			Handler:    _Event_OrderPlacementFailedEvent_Handler,
		},
		{
			MethodName: "OrderCancellationEvent",
			Handler:    _Event_OrderCancellationEvent_Handler,
		},
		{
			MethodName: "OrderCancellationFailedEvent",
			Handler:    _Event_OrderCancellationFailedEvent_Handler,
		},
		{
			MethodName: "OrderMatchingEvent",
			Handler:    _Event_OrderMatchingEvent_Handler,
		},
		{
			MethodName: "OrderMatchingFailedEvent",
			Handler:    _Event_OrderMatchingFailedEvent_Handler,
		},
		{
			MethodName: "OrderPartialFillEvent",
			Handler:    _Event_OrderPartialFillEvent_Handler,
		},
		{
			MethodName: "OrderFulfillmentEvent",
			Handler:    _Event_OrderFulfillmentEvent_Handler,
		},
		{
			MethodName: "OrderInitializeEvent",
			Handler:    _Event_OrderInitializeEvent_Handler,
		},
		{
			MethodName: "BalanceUpdateEvent",
			Handler:    _Event_BalanceUpdateEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	OrderBook_GetOrderBook_FullMethodName = "/grpc_order.OrderBook/GetOrderBook"
)

// OrderBookClient is the client API for OrderBook service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderBookClient interface {
	GetOrderBook(ctx context.Context, in *GetOrderBookInput, opts ...grpc.CallOption) (*GetOrderBookOutput, error)
}

type orderBookClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderBookClient(cc grpc.ClientConnInterface) OrderBookClient {
	return &orderBookClient{cc}
}

func (c *orderBookClient) GetOrderBook(ctx context.Context, in *GetOrderBookInput, opts ...grpc.CallOption) (*GetOrderBookOutput, error) {
	out := new(GetOrderBookOutput)
	err := c.cc.Invoke(ctx, OrderBook_GetOrderBook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderBookServer is the server API for OrderBook service.
// All implementations must embed UnimplementedOrderBookServer
// for forward compatibility
type OrderBookServer interface {
	GetOrderBook(context.Context, *GetOrderBookInput) (*GetOrderBookOutput, error)
	mustEmbedUnimplementedOrderBookServer()
}

// UnimplementedOrderBookServer must be embedded to have forward compatible implementations.
type UnimplementedOrderBookServer struct {
}

func (UnimplementedOrderBookServer) GetOrderBook(context.Context, *GetOrderBookInput) (*GetOrderBookOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderBook not implemented")
}
func (UnimplementedOrderBookServer) mustEmbedUnimplementedOrderBookServer() {}

// UnsafeOrderBookServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderBookServer will
// result in compilation errors.
type UnsafeOrderBookServer interface {
	mustEmbedUnimplementedOrderBookServer()
}

func RegisterOrderBookServer(s grpc.ServiceRegistrar, srv OrderBookServer) {
	s.RegisterService(&OrderBook_ServiceDesc, srv)
}

func _OrderBook_GetOrderBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderBookInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderBookServer).GetOrderBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderBook_GetOrderBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderBookServer).GetOrderBook(ctx, req.(*GetOrderBookInput))
	}
	return interceptor(ctx, in, info, handler)
}

// OrderBook_ServiceDesc is the grpc.ServiceDesc for OrderBook service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderBook_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.OrderBook",
	HandlerType: (*OrderBookServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrderBook",
			Handler:    _OrderBook_GetOrderBook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	PlacementProcess_Placement_FullMethodName = "/grpc_order.PlacementProcess/Placement"
)

// PlacementProcessClient is the client API for PlacementProcess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlacementProcessClient interface {
	Placement(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error)
}

type placementProcessClient struct {
	cc grpc.ClientConnInterface
}

func NewPlacementProcessClient(cc grpc.ClientConnInterface) PlacementProcessClient {
	return &placementProcessClient{cc}
}

func (c *placementProcessClient) Placement(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, PlacementProcess_Placement_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlacementProcessServer is the server API for PlacementProcess service.
// All implementations must embed UnimplementedPlacementProcessServer
// for forward compatibility
type PlacementProcessServer interface {
	Placement(context.Context, *Order) (*Ack, error)
	mustEmbedUnimplementedPlacementProcessServer()
}

// UnimplementedPlacementProcessServer must be embedded to have forward compatible implementations.
type UnimplementedPlacementProcessServer struct {
}

func (UnimplementedPlacementProcessServer) Placement(context.Context, *Order) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Placement not implemented")
}
func (UnimplementedPlacementProcessServer) mustEmbedUnimplementedPlacementProcessServer() {}

// UnsafePlacementProcessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlacementProcessServer will
// result in compilation errors.
type UnsafePlacementProcessServer interface {
	mustEmbedUnimplementedPlacementProcessServer()
}

func RegisterPlacementProcessServer(s grpc.ServiceRegistrar, srv PlacementProcessServer) {
	s.RegisterService(&PlacementProcess_ServiceDesc, srv)
}

func _PlacementProcess_Placement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementProcessServer).Placement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlacementProcess_Placement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementProcessServer).Placement(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

// PlacementProcess_ServiceDesc is the grpc.ServiceDesc for PlacementProcess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlacementProcess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.PlacementProcess",
	HandlerType: (*PlacementProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Placement",
			Handler:    _PlacementProcess_Placement_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	RefundProcess_MarketAskRefund_FullMethodName = "/grpc_order.RefundProcess/MarketAskRefund"
	RefundProcess_MarketBidRefund_FullMethodName = "/grpc_order.RefundProcess/MarketBidRefund"
	RefundProcess_LimitAskRefund_FullMethodName  = "/grpc_order.RefundProcess/LimitAskRefund"
	RefundProcess_LimitBidRefund_FullMethodName  = "/grpc_order.RefundProcess/LimitBidRefund"
)

// RefundProcessClient is the client API for RefundProcess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RefundProcessClient interface {
	MarketAskRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error)
	MarketBidRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error)
	LimitAskRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error)
	LimitBidRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error)
}

type refundProcessClient struct {
	cc grpc.ClientConnInterface
}

func NewRefundProcessClient(cc grpc.ClientConnInterface) RefundProcessClient {
	return &refundProcessClient{cc}
}

func (c *refundProcessClient) MarketAskRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, RefundProcess_MarketAskRefund_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refundProcessClient) MarketBidRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, RefundProcess_MarketBidRefund_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refundProcessClient) LimitAskRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, RefundProcess_LimitAskRefund_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refundProcessClient) LimitBidRefund(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, RefundProcess_LimitBidRefund_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RefundProcessServer is the server API for RefundProcess service.
// All implementations must embed UnimplementedRefundProcessServer
// for forward compatibility
type RefundProcessServer interface {
	MarketAskRefund(context.Context, *Order) (*Ack, error)
	MarketBidRefund(context.Context, *Order) (*Ack, error)
	LimitAskRefund(context.Context, *Order) (*Ack, error)
	LimitBidRefund(context.Context, *Order) (*Ack, error)
	mustEmbedUnimplementedRefundProcessServer()
}

// UnimplementedRefundProcessServer must be embedded to have forward compatible implementations.
type UnimplementedRefundProcessServer struct {
}

func (UnimplementedRefundProcessServer) MarketAskRefund(context.Context, *Order) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketAskRefund not implemented")
}
func (UnimplementedRefundProcessServer) MarketBidRefund(context.Context, *Order) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBidRefund not implemented")
}
func (UnimplementedRefundProcessServer) LimitAskRefund(context.Context, *Order) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitAskRefund not implemented")
}
func (UnimplementedRefundProcessServer) LimitBidRefund(context.Context, *Order) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitBidRefund not implemented")
}
func (UnimplementedRefundProcessServer) mustEmbedUnimplementedRefundProcessServer() {}

// UnsafeRefundProcessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RefundProcessServer will
// result in compilation errors.
type UnsafeRefundProcessServer interface {
	mustEmbedUnimplementedRefundProcessServer()
}

func RegisterRefundProcessServer(s grpc.ServiceRegistrar, srv RefundProcessServer) {
	s.RegisterService(&RefundProcess_ServiceDesc, srv)
}

func _RefundProcess_MarketAskRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefundProcessServer).MarketAskRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefundProcess_MarketAskRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefundProcessServer).MarketAskRefund(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefundProcess_MarketBidRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefundProcessServer).MarketBidRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefundProcess_MarketBidRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefundProcessServer).MarketBidRefund(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefundProcess_LimitAskRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefundProcessServer).LimitAskRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefundProcess_LimitAskRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefundProcessServer).LimitAskRefund(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefundProcess_LimitBidRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefundProcessServer).LimitBidRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefundProcess_LimitBidRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefundProcessServer).LimitBidRefund(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

// RefundProcess_ServiceDesc is the grpc.ServiceDesc for RefundProcess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RefundProcess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.RefundProcess",
	HandlerType: (*RefundProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MarketAskRefund",
			Handler:    _RefundProcess_MarketAskRefund_Handler,
		},
		{
			MethodName: "MarketBidRefund",
			Handler:    _RefundProcess_MarketBidRefund_Handler,
		},
		{
			MethodName: "LimitAskRefund",
			Handler:    _RefundProcess_LimitAskRefund_Handler,
		},
		{
			MethodName: "LimitBidRefund",
			Handler:    _RefundProcess_LimitBidRefund_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	MatchProcess_LimitBidBigger_FullMethodName   = "/grpc_order.MatchProcess/LimitBidBigger"
	MatchProcess_LimitBidEqual_FullMethodName    = "/grpc_order.MatchProcess/LimitBidEqual"
	MatchProcess_LimitBidSmaller_FullMethodName  = "/grpc_order.MatchProcess/LimitBidSmaller"
	MatchProcess_MarketBidBigger_FullMethodName  = "/grpc_order.MatchProcess/MarketBidBigger"
	MatchProcess_MarketBidEqual_FullMethodName   = "/grpc_order.MatchProcess/MarketBidEqual"
	MatchProcess_MarketBidSmaller_FullMethodName = "/grpc_order.MatchProcess/MarketBidSmaller"
	MatchProcess_LimitAskBigger_FullMethodName   = "/grpc_order.MatchProcess/LimitAskBigger"
	MatchProcess_LimitAskEqual_FullMethodName    = "/grpc_order.MatchProcess/LimitAskEqual"
	MatchProcess_LimitAskSmaller_FullMethodName  = "/grpc_order.MatchProcess/LimitAskSmaller"
	MatchProcess_MarketAskBigger_FullMethodName  = "/grpc_order.MatchProcess/MarketAskBigger"
	MatchProcess_MarketAskEqual_FullMethodName   = "/grpc_order.MatchProcess/MarketAskEqual"
	MatchProcess_MarketAskSmaller_FullMethodName = "/grpc_order.MatchProcess/MarketAskSmaller"
)

// MatchProcessClient is the client API for MatchProcess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MatchProcessClient interface {
	LimitBidBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	LimitBidEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	LimitBidSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketBidBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketBidEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketBidSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	LimitAskBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	LimitAskEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	LimitAskSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketAskBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketAskEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
	MarketAskSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error)
}

type matchProcessClient struct {
	cc grpc.ClientConnInterface
}

func NewMatchProcessClient(cc grpc.ClientConnInterface) MatchProcessClient {
	return &matchProcessClient{cc}
}

func (c *matchProcessClient) LimitBidBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitBidBigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) LimitBidEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitBidEqual_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) LimitBidSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitBidSmaller_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketBidBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketBidBigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketBidEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketBidEqual_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketBidSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketBidSmaller_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) LimitAskBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitAskBigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) LimitAskEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitAskEqual_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) LimitAskSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_LimitAskSmaller_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketAskBigger(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketAskBigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketAskEqual(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketAskEqual_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchProcessClient) MarketAskSmaller(ctx context.Context, in *BidAsk, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, MatchProcess_MarketAskSmaller_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchProcessServer is the server API for MatchProcess service.
// All implementations must embed UnimplementedMatchProcessServer
// for forward compatibility
type MatchProcessServer interface {
	LimitBidBigger(context.Context, *BidAsk) (*Ack, error)
	LimitBidEqual(context.Context, *BidAsk) (*Ack, error)
	LimitBidSmaller(context.Context, *BidAsk) (*Ack, error)
	MarketBidBigger(context.Context, *BidAsk) (*Ack, error)
	MarketBidEqual(context.Context, *BidAsk) (*Ack, error)
	MarketBidSmaller(context.Context, *BidAsk) (*Ack, error)
	LimitAskBigger(context.Context, *BidAsk) (*Ack, error)
	LimitAskEqual(context.Context, *BidAsk) (*Ack, error)
	LimitAskSmaller(context.Context, *BidAsk) (*Ack, error)
	MarketAskBigger(context.Context, *BidAsk) (*Ack, error)
	MarketAskEqual(context.Context, *BidAsk) (*Ack, error)
	MarketAskSmaller(context.Context, *BidAsk) (*Ack, error)
	mustEmbedUnimplementedMatchProcessServer()
}

// UnimplementedMatchProcessServer must be embedded to have forward compatible implementations.
type UnimplementedMatchProcessServer struct {
}

func (UnimplementedMatchProcessServer) LimitBidBigger(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitBidBigger not implemented")
}
func (UnimplementedMatchProcessServer) LimitBidEqual(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitBidEqual not implemented")
}
func (UnimplementedMatchProcessServer) LimitBidSmaller(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitBidSmaller not implemented")
}
func (UnimplementedMatchProcessServer) MarketBidBigger(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBidBigger not implemented")
}
func (UnimplementedMatchProcessServer) MarketBidEqual(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBidEqual not implemented")
}
func (UnimplementedMatchProcessServer) MarketBidSmaller(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBidSmaller not implemented")
}
func (UnimplementedMatchProcessServer) LimitAskBigger(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitAskBigger not implemented")
}
func (UnimplementedMatchProcessServer) LimitAskEqual(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitAskEqual not implemented")
}
func (UnimplementedMatchProcessServer) LimitAskSmaller(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimitAskSmaller not implemented")
}
func (UnimplementedMatchProcessServer) MarketAskBigger(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketAskBigger not implemented")
}
func (UnimplementedMatchProcessServer) MarketAskEqual(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketAskEqual not implemented")
}
func (UnimplementedMatchProcessServer) MarketAskSmaller(context.Context, *BidAsk) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketAskSmaller not implemented")
}
func (UnimplementedMatchProcessServer) mustEmbedUnimplementedMatchProcessServer() {}

// UnsafeMatchProcessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchProcessServer will
// result in compilation errors.
type UnsafeMatchProcessServer interface {
	mustEmbedUnimplementedMatchProcessServer()
}

func RegisterMatchProcessServer(s grpc.ServiceRegistrar, srv MatchProcessServer) {
	s.RegisterService(&MatchProcess_ServiceDesc, srv)
}

func _MatchProcess_LimitBidBigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitBidBigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitBidBigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitBidBigger(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_LimitBidEqual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitBidEqual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitBidEqual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitBidEqual(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_LimitBidSmaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitBidSmaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitBidSmaller_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitBidSmaller(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketBidBigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketBidBigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketBidBigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketBidBigger(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketBidEqual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketBidEqual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketBidEqual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketBidEqual(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketBidSmaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketBidSmaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketBidSmaller_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketBidSmaller(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_LimitAskBigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitAskBigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitAskBigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitAskBigger(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_LimitAskEqual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitAskEqual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitAskEqual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitAskEqual(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_LimitAskSmaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).LimitAskSmaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_LimitAskSmaller_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).LimitAskSmaller(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketAskBigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketAskBigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketAskBigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketAskBigger(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketAskEqual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketAskEqual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketAskEqual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketAskEqual(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchProcess_MarketAskSmaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidAsk)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchProcessServer).MarketAskSmaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchProcess_MarketAskSmaller_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchProcessServer).MarketAskSmaller(ctx, req.(*BidAsk))
	}
	return interceptor(ctx, in, info, handler)
}

// MatchProcess_ServiceDesc is the grpc.ServiceDesc for MatchProcess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MatchProcess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.MatchProcess",
	HandlerType: (*MatchProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LimitBidBigger",
			Handler:    _MatchProcess_LimitBidBigger_Handler,
		},
		{
			MethodName: "LimitBidEqual",
			Handler:    _MatchProcess_LimitBidEqual_Handler,
		},
		{
			MethodName: "LimitBidSmaller",
			Handler:    _MatchProcess_LimitBidSmaller_Handler,
		},
		{
			MethodName: "MarketBidBigger",
			Handler:    _MatchProcess_MarketBidBigger_Handler,
		},
		{
			MethodName: "MarketBidEqual",
			Handler:    _MatchProcess_MarketBidEqual_Handler,
		},
		{
			MethodName: "MarketBidSmaller",
			Handler:    _MatchProcess_MarketBidSmaller_Handler,
		},
		{
			MethodName: "LimitAskBigger",
			Handler:    _MatchProcess_LimitAskBigger_Handler,
		},
		{
			MethodName: "LimitAskEqual",
			Handler:    _MatchProcess_LimitAskEqual_Handler,
		},
		{
			MethodName: "LimitAskSmaller",
			Handler:    _MatchProcess_LimitAskSmaller_Handler,
		},
		{
			MethodName: "MarketAskBigger",
			Handler:    _MatchProcess_MarketAskBigger_Handler,
		},
		{
			MethodName: "MarketAskEqual",
			Handler:    _MatchProcess_MarketAskEqual_Handler,
		},
		{
			MethodName: "MarketAskSmaller",
			Handler:    _MatchProcess_MarketAskSmaller_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}

const (
	ErrorProcess_Error_FullMethodName = "/grpc_order.ErrorProcess/Error"
)

// ErrorProcessClient is the client API for ErrorProcess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ErrorProcessClient interface {
	Error(ctx context.Context, in *ErrorInput, opts ...grpc.CallOption) (*Ack, error)
}

type errorProcessClient struct {
	cc grpc.ClientConnInterface
}

func NewErrorProcessClient(cc grpc.ClientConnInterface) ErrorProcessClient {
	return &errorProcessClient{cc}
}

func (c *errorProcessClient) Error(ctx context.Context, in *ErrorInput, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, ErrorProcess_Error_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ErrorProcessServer is the server API for ErrorProcess service.
// All implementations must embed UnimplementedErrorProcessServer
// for forward compatibility
type ErrorProcessServer interface {
	Error(context.Context, *ErrorInput) (*Ack, error)
	mustEmbedUnimplementedErrorProcessServer()
}

// UnimplementedErrorProcessServer must be embedded to have forward compatible implementations.
type UnimplementedErrorProcessServer struct {
}

func (UnimplementedErrorProcessServer) Error(context.Context, *ErrorInput) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Error not implemented")
}
func (UnimplementedErrorProcessServer) mustEmbedUnimplementedErrorProcessServer() {}

// UnsafeErrorProcessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ErrorProcessServer will
// result in compilation errors.
type UnsafeErrorProcessServer interface {
	mustEmbedUnimplementedErrorProcessServer()
}

func RegisterErrorProcessServer(s grpc.ServiceRegistrar, srv ErrorProcessServer) {
	s.RegisterService(&ErrorProcess_ServiceDesc, srv)
}

func _ErrorProcess_Error_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorProcessServer).Error(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ErrorProcess_Error_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorProcessServer).Error(ctx, req.(*ErrorInput))
	}
	return interceptor(ctx, in, info, handler)
}

// ErrorProcess_ServiceDesc is the grpc.ServiceDesc for ErrorProcess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ErrorProcess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_order.ErrorProcess",
	HandlerType: (*ErrorProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Error",
			Handler:    _ErrorProcess_Error_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/grpc_order/service.proto",
}
